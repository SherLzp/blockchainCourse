## 一．算法设计

#### **(1)** 字符串的处理

填充字符串末尾，使其长度在对512取模以后的余数是448：先补第一个比特为1，然后都补0，直到长度满足对512取模后余数是448。此时再在填充字符串末尾加上表示原始字符串长度的64位数据，则有：448+64=512，刚好拼成一个完整的结构，用于下一步算法的迭代实现。 

#### **(2)** 将输入的字符串str转换成N个大小为512bit的块

整个算法不断进行迭代，每次迭代产生结果Hi，Map(Hi-1) = Hi，通过N次迭代产生HN，即256bit的结果哈希值。将该256bit的哈希值分成8块，每块32bit，恰好是一个字word。所以可以将每次迭代看成是8个子部分的迭代。

#### (3)每一次迭代Map(Hi-1) = Hi的具体实现方式

原始字符串(N*512bits)，可以分成N块，每块512bits，将每一块分解为16个32bits (16*32=512)的字，记为w[0], …, w[15]， 前16个字直接由字符串的第i个块分解得到。

第一次迭代将映射的初始值设置为自然数前8个质数的平方根的小数部分的前32位。

其余的字由如下迭代公式得到：

![img](file:///C:\Users\DELL\AppData\Local\Temp\ksohtml15040\wps1.jpg) 

#### (4)64个加密循环完成一次迭代

将初始的8个字，即自然数的前8个质数的平方根的小数部分的前32位，按照一定的规则进行更新。每次迭代后的初始值分别为H[i-1][0],H[i-1][1],…,H[i-1][7].

设置64个密钥K[64]：自然数前64个质数的平方根的小数部分的前32位。

Wt是本区块产生第t个word。原消息被切成固定长度512-bit的区块，对每一个区块，产生64个word，通过重复运行循环n次对每次迭代传下来的那八个字循环加密。最后一次循环所产生的八个字合起来就是第i个块对应到的散列字符串Hi。即，完成了哈希算法。

 

##### 经过多次实验和正确的SHA256算法下多个字符串的哈希值进行对比，该实验结果正确。

## 二．实验数据说明

通过不断输入字符串，用SHA256算法进行实验，总结出SHA256的以下几点特点：

#### **(1)** SHA256在验证改动方面有着巨大的优势。

只要输入数据有微小的区别，通过SHA256产生的哈希值都会有巨大的差距。如下面3个字符串，原文仅仅存在微小的不同，但是通过SHA256的哈希处理所产生的哈希值的差异巨大，且这种差异毫无规律可循。
str1：1 
SHA156-Value: 6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b

Str2：2 
SHA156-Value: d4735e3a265e16eee03f59718b9b5d03019c07d8b6c51f90da3a666eec13ab35

Str2：3 
SHA156-Value: 4e07408562bedb8b60ce05c1decfe3ad16b72230967de01f640b7e4729b49fce

基于这个特性，SHA-256成为了比特币网络的重要组成部分:

参与比特币地址的创建，区块链可以基于哈希值进行连接。每一个区块中保留了上一个区块的哈希值，merkle根也是由SHA-256创建的，并放置在块头中。层层相扣的结构以及分布式账本的记账机制维护了区块链的加密性。在自动生成输入的同时，任何用户都可以随机生成输出。任何人都无法更改或中断现有输入。使得区块链中数据无法篡改或删除。同时由于SHA-256的唯一性，区块头对应产生的哈希值可以作为区块的标识符，维护了比特币的唯一性。

#### **(2)** SHA256可作为公平比特币获取的依据。

通过算法可知，SHA256加密的过程、计算、产生的过程中存在众多的位运算等逻辑运算，对算力的要求很高。是对计算机算力比拼的一个很好的机制。

机器通过运行SHA256程序不断的生成随机数，在众多机器中，谁先生成符合的随机数谁就可以得到该比特币，如，设置谁先生成前四位均为0的哈希值谁就可以获得该次的比特币，这种机制实现了对计算机算力的考验，也实现了比特币在算力面向相对公平的竞争，不会存在普通货币所谓的“阶级差距”、“贫富差距”带来的购买力的不同。



## 三.代码运行方法

 用VS2017建立C++项目，将SHA256.cpp, SHA256.h, main.cpp文件分别导入，编译运行即可。输入字符串即可获取相应哈希值。

