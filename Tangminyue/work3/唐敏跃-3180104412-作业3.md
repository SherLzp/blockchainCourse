# Fabric 交易流程源码分析

[TOC]

## 参与交易的节点类型

一个完整的Fabric交易一般要涉及应用程序、证书服务、背书节点、提交节点和排序节点。

客户端（Client）：调用Fabric SDK与区块链网络进行交互；

证书节点（ CA ）：负责对网络中所有的证书进行管理，提供标准的PKI服务；

背书节点（ Endorser ）：负责对交易的提案（ proposal）进行验证并进行模拟执行。背书节点相当于中立的第三方，用来保证交易的合法性；

排序节点（ Orderer ）：对所有发往网络中的交易进行排序，将排序后的交易按照配置中的约定整理为区块，之后广播给提交节点（committer）进行处理；

提交节点（ Committer ）：负责再次检查交易的合法性，接受合法交易对账本的修改，并写入区块链结构；

## 源码分析

### Client端处理流程

默认客户端已经通过证书服务获取合法的身份并加入到应用通道（Channel）中

调用入口在`peer/chaincode/invoke.go`

`invokeCmd` 函数将链码转换成cobra命令

```go
// invokeCmd returns the cobra command for Chaincode Invoke
func invokeCmd(cf *ChaincodeCmdFactory, cryptoProvider bccsp.BCCSP) *cobra.Command {
	chaincodeInvokeCmd = &cobra.Command{
		Use:       "invoke",
		Short:     fmt.Sprintf("Invoke the specified %s.", chainFuncName),
		Long:      fmt.Sprintf("Invoke the specified %s. It will try to commit the endorsed transaction to the network.", chainFuncName),
		ValidArgs: []string{"1"},
		RunE: func(cmd *cobra.Command, args []string) error {
			return chaincodeInvoke(cmd, cf, cryptoProvider)
		},
	}
	flagList := []string{
		"name",
		"ctor",
		"isInit",
		"channelID",
		"peerAddresses",
		"tlsRootCertFiles",
		"connectionProfile",
		"waitForEvent",
		"waitForEventTimeout",
	}
	attachFlags(chaincodeInvokeCmd, flagList)

	return chaincodeInvokeCmd
}
```

接下来函数的调用流程为`chaincodeInvoke`,  `chaincodeInvokeOrQuery` , `ChaincodeInvokeOrQuery`

主要的操作在`ChaincodeInvokeOrQuery`中，正常的处理流程分为6步操作：

1. 创建一个给定序列化身份的交易提案
2. 对提案进行身份签名
3. 处理提案，通过grpc发送给endorser处理
4. 背书成功，组装一个签名的交易
5. 广播交易给orderer节点
6. 提交给Committer 节点，存储到区块链中

```go
func ChaincodeInvokeOrQuery(
	spec *pb.ChaincodeSpec,
	cID string,
	txID string,
	invoke bool,
	signer identity.SignerSerializer,
	certificate tls.Certificate,
	endorserClients []pb.EndorserClient,
	deliverClients []pb.DeliverClient,
	bc common.BroadcastClient,
) (*pb.ProposalResponse, error) {
	// Build the ChaincodeInvocationSpec message
	invocation := &pb.ChaincodeInvocationSpec{ChaincodeSpec: spec}

	creator, err := signer.Serialize()
	if err != nil {
		return nil, errors.WithMessage(err, "error serializing identity")
	}

	funcName := "invoke"
	if !invoke {
		funcName = "query"
	}

	// extract the transient field if it exists
	var tMap map[string][]byte
	if transient != "" {
		if err := json.Unmarshal([]byte(transient), &tMap); err != nil {
			return nil, errors.Wrap(err, "error parsing transient string")
		}
	}

     // 创建一个给定序列化身份的交易提案
	prop, txid, err := protoutil.CreateChaincodeProposalWithTxIDAndTransient(pcommon.HeaderType_ENDORSER_TRANSACTION, cID, invocation, creator, txID, tMap)
	if err != nil {
		return nil, errors.WithMessagef(err, "error creating proposal for %s", funcName)
	}
	
	// 返回了一个给出提案消息和签名身份的签名提案
	signedProp, err := protoutil.GetSignedProposal(prop, signer)
	if err != nil {
		return nil, errors.WithMessagef(err, "error creating signed proposal for %s", funcName)
	}

    // 处理提案，通过grpc发送给endorser处理
	responses, err := processProposals(endorserClients, signedProp)
	if err != nil {
		return nil, errors.WithMessagef(err, "error endorsing %s", funcName)
	}

	if len(responses) == 0 {
		return nil, errors.New("no proposal responses received - this might indicate a bug")
	}

	proposalResp := responses[0]

	if invoke {
		if proposalResp != nil {
			if proposalResp.Response.Status >= shim.ERRORTHRESHOLD {
				return proposalResp, nil
			}
            // 组装一个签名的交易（这是一个信封信息）
			env, err := protoutil.CreateSignedTx(prop, signer, responses...)

			if err != nil {
				return proposalResp, errors.WithMessage(err, "could not assemble transaction")
			}
			var dg *DeliverGroup
			var ctx context.Context
			if waitForEvent {
				var cancelFunc context.CancelFunc
				ctx, cancelFunc = context.WithTimeout(context.Background(), waitForEventTimeout)
				defer cancelFunc()

				dg = NewDeliverGroup(
					deliverClients,
					peerAddresses,
					signer,
					certificate,
					channelID,
					txid,
				)
				// connect to deliver service on all peers
				err := dg.Connect(ctx)
				if err != nil {
					return nil, err
				}
			}
            
            // 广播发送信封给orderer
			if err = bc.Send(env); err != nil {
				return proposalResp, errors.WithMessagef(err, "error sending transaction for %s", funcName)
			}

			if dg != nil && ctx != nil {
				// wait for event that contains the txid from all peers
				err = dg.Wait(ctx)
				if err != nil {
					return nil, err
				}
			}
		}
	}

	return proposalResp, nil
}
```



第3步操作调用的函数：发送已签名的提案给endorser节点，并返回背书回复

```go
// processProposals sends a signed proposal to a set of peers, and gathers all the responses.
func processProposals(endorserClients []pb.EndorserClient, signedProposal *pb.SignedProposal) ([]*pb.ProposalResponse, error) {
	responsesCh := make(chan *pb.ProposalResponse, len(endorserClients))
	errorCh := make(chan error, len(endorserClients))
	wg := sync.WaitGroup{}
	for _, endorser := range endorserClients {
		wg.Add(1)
		go func(endorser pb.EndorserClient) {
			defer wg.Done()
			proposalResp, err := endorser.ProcessProposal(context.Background(), signedProposal)
			if err != nil {
				errorCh <- err
				return
			}
			responsesCh <- proposalResp
		}(endorser)
	}
	wg.Wait()
	close(responsesCh)
	close(errorCh)
	for err := range errorCh {
		return nil, err
	}
	var responses []*pb.ProposalResponse
	for response := range responsesCh {
		responses = append(responses, response)
	}
	return responses, nil
}
```



第5步操作中广播给orderer节点的接口：

```go
type BroadcastClient interface {
       //Send data to orderer
       Send(env *cb.Envelope) error
       Close() error
}
func (s *broadcastClient) Send(env *cb.Envelope) error {
    //发送给orderer
	if err := s.client.Send(env); err != nil {
		return fmt.Errorf("Could not send :%s)", err)
	}
    //同步等待消息返回
	err := s.getAck()

	return err
}
```



### Endorser处理流程

endorser节点的处理函数：`ProcessProposal`

```go
// ProcessProposal process the Proposal
func (e *Endorser) ProcessProposal(ctx context.Context, signedProp *pb.SignedProposal) (*pb.ProposalResponse, error) {
	// start time for computing elapsed time metric for successfully endorsed proposals
	startTime := time.Now()
	e.Metrics.ProposalsReceived.Add(1)

	addr := util.ExtractRemoteAddress(ctx)
	endorserLogger.Debug("request from", addr)

	// variables to capture proposal duration metric
	success := false

    // 检验消息有效性
	up, err := UnpackProposal(signedProp)
	if err != nil {
		e.Metrics.ProposalValidationFailed.Add(1)
		return &pb.ProposalResponse{Response: &pb.Response{Status: 500, Message: err.Error()}}, err
	}

    // 获取ChannelID
	var channel *Channel
	if up.ChannelID() != "" {
		channel = e.ChannelFetcher.Channel(up.ChannelID())
		if channel == nil {
			return &pb.ProposalResponse{Response: &pb.Response{Status: 500, Message: fmt.Sprintf("channel '%s' not found", up.ChannelHeader.ChannelId)}}, nil
		}
	} else {
		channel = &Channel{
			IdentityDeserializer: e.LocalMSP,
		}
	}

    // 检查ACL - 我们验证此提案符合链条的政策
	err = e.preProcess(up, channel)
	if err != nil {
		return &pb.ProposalResponse{Response: &pb.Response{Status: 500, Message: err.Error()}}, err
	}

	defer func() {
		meterLabels := []string{
			"channel", up.ChannelHeader.ChannelId,
			"chaincode", up.ChaincodeName,
			"success", strconv.FormatBool(success),
		}
		e.Metrics.ProposalDuration.With(meterLabels...).Observe(time.Since(startTime).Seconds())
	}()

    // 模拟提案
	pResp, err := e.ProcessProposalSuccessfullyOrError(up)
	if err != nil {
		return &pb.ProposalResponse{Response: &pb.Response{Status: 500, Message: err.Error()}}, nil
	}

	if pResp.Endorsement != nil || up.ChannelHeader.ChannelId == "" {
		success = true
		e.Metrics.SuccessfulProposals.Add(1)
	}
    // 将消息返回给客户端
	return pResp, nil
}
```

endorser处理完后，消息返回给客户端，消息再发送到orderer



### Orderer节点处理流程（kafka消息处理机制）

消息接收接口：`Broadcast`

```go
// Broadcast receives a stream of messages from a client for ordering
// Broadcast主要接收Client的数据并在Orderer里面生成一系列数据块
func (s *server) Broadcast(srv ab.AtomicBroadcast_BroadcastServer) error {
	logger.Debugf("Starting new Broadcast handler")
	//中间部分省略
	return s.bh.Handle(&broadcastMsgTracer{
		AtomicBroadcast_BroadcastServer: srv,
		msgTracer: msgTracer{
			debug:    s.debug,
			function: "Broadcast",
		},
	})
}
```

消息发送接口：`Deliver`

```go
// Deliver sends a stream of blocks to a client after ordering
// Deliver负责排序后向Client发送消息
func (s *server) Deliver(srv ab.AtomicBroadcast_DeliverServer) error {
	logger.Debugf("Starting new Deliver handler")
	// 中间部分省略
	return s.dh.Handle(srv.Context(), deliverServer)
}
```

主处理函数：`Handle`

```go
// Handle reads requests from a Broadcast stream, processes them, and returns the responses to the stream
func (bh *Handler) Handle(srv ab.AtomicBroadcast_BroadcastServer) error {
	addr := util.ExtractRemoteAddress(srv.Context())
	logger.Debugf("Starting new broadcast loop for %s", addr)
	for {
        // 处理消息接收
		msg, err := srv.Recv()
		if err == io.EOF {
			logger.Debugf("Received EOF from %s, hangup", addr)
			return nil
		}
		if err != nil {
			logger.Warningf("Error reading from %s: %s", addr, err)
			return err
		}
	
        // 处理消息发送
		resp := bh.ProcessMessage(msg, addr)
		err = srv.Send(resp)
		if resp.Status != cb.Status_SUCCESS {
			return err
		}

		if err != nil {
			logger.Warningf("Error sending to %s: %s", addr, err)
			return err
		}
	}

}
```



### Committer 节点处理流程

监听提交请求，启动协程处理数据

```go
// NewGossipStateProvider creates state provider with coordinator instance
// to orchestrate arrival of private rwsets and blocks before committing them into the ledger.
func NewGossipStateProvider(
	logger util.Logger,
	chainID string,
	services *ServicesMediator,
	ledger ledgerResources,
	stateMetrics *metrics.StateMetrics,
	blockingMode bool,
	config *StateConfig,
) GossipStateProvider {
    // 具体代码省略
}
```



存储到区块链中

```go
func (c *coordinator) StoreBlock(block *common.Block, privateDataSets util.PvtDataCollections) error {
    // 具体代码省略
}
```



### 备注

唐敏跃 3180104412

能力有限，能读懂的源码很少，只能结合网络上的文章进行分析